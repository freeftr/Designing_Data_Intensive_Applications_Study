# 07장 트랜잭션

- 트랜잭션: 여러 개의 읽기/쓰기 명령을 하나의 논리적인 단위로 묶는 것. => **부분적인 실패**를 방지
  - commit
  - rollback

***
## 애매모호한 트랜잭션의 개념

### 원자성
- 더 쪼갤 수 없는 작은 부분으로 전부 되거나/안 되거나를 보장.

### 일관성
- 데이터에 대한 불변식을 만족하는 것.

### 격리성
- 동시에 실행되는 트랜잭션은 격리되어야 함. => 순차적 실행.

### 지속성
- 커밋 시 트랜잭션에서 기록한 데이터의 영속성 보장.

***
## 단일 객체 연산과 다중 객체 연산

### 단일 객체 쓰기
- 단일 객체도 원자성, 격리성이 필요.
  - 원자성: 장애 복구용 로그
  - 격리성: 락
- 사실상 락의 역할

### 다중 객체 트랜잭션
- 여러 데이터를 한 번에 갱신하거나 삽입해야 하는 경우.

### 오류와 어보트 처리
- 되거나/안되거나
- 어보트 = 안전하게 재시도를 하기 위함.
- 오류에 따라 재시도를 하고 말고 정해야 함.

***
## 완화된 격리 수준

### 커밋 후 읽기
- 커밋된 데이터만 볼 수 있게. = 더티 읽기 X
- 커밋된 데이터만 덮어쓸 수 있게. = 더티 쓰기 X

### 커밋 후 읽기 구현
- 로우 수준 잠금: 해당 객체에 대한 잠금을 가진 트랜잭션만 작동.
- 읽을 때는 과거의 값을 읽어옴.

### 스냅숏 격리와 반복 읽기
- read skew: 트랜잭션 진행중인 작업을 읽을 시 생기는 시간적 이상 현상.
  - 근데 결국 시간이 지나면 일관적인 데이터를 볼 수 있다. => 도메인이 요구하는 일시적인 일관성에 대한 것이 중요.
- 스냅숏 격리: 각 트랜잭션은 데이터베이스의 일관된 스냅숏을 읽음. => 일관성 유지.

### 스냅숏 격리 구현
- 쓰기 잠금: 같은 객체에 쓰는 다른 트랜잭션 차단.
  - 읽을 때는 아무 상관이 없음.
  - MVCC

### 일관된 스냅숏을 보는 가시성 규칙
- 트랜잭션 ID를 통해 볼 수 있는 데이터 제한.
1. 트랜잭션을 열 때, 그 시점 진행중인 모든 트랜잭션 목록 만들고, 무시.
2. Abort 트랜잭션 모두 무시.
3. 트랜잭션 ID가 더 큰 데이터 모두 무시.

### 색인과 스냅숏 격리
- 색인이 모든 버전을 가리키고, 현재 트랜잭션에서 볼 수 없는 버전 거르기.
- 변경된 페이지만 복수하고, 자식 페이지들의 새 버전을 가리키도록 변경.

***
## 갱신 손실 방지
- lost update: 커밋되지 않은 값을 읽어 두 트랜잭션이 갱신 시 충돌 발생.
  - 카운터가 1일 때 카운터를 1 증가시키는 두 트랜잭션이 접근.
  - 각각 1을 읽어와서 최종 값 = 2 (3이 되어야 함)

### 원자적 쓰기 연산
- 갱신을 순차적으로 실행시키기.

### 명시적인 잠금
- 애플리케이션에서 잠금을 설정하여 read-modify-write 구현.

### 갱신 자동 손실 감지
- 트랜잭션의 병렬 실행을 허용하고, 트랜잭션 관리자가 갱신 손실을 감지하고 재시도하는 방법.
  - DB에 따라 다름. (MySQL의 반복 읽기는 갱신 손실을 감지하지 않는다.)

### Compare-and-set
- 마지막으로 읽은 값이 변경되지 않았을 경우 갱신 허용 => Redis의 WATCH가 이에 해당.
~~~sql
UPDATE members SET name = '새 이름' WHERE id = 1234 AND name = '기존 이름'
~~~

### 충돌 해소와 복제
- 다중 리더거나 리더 없는 복제일 경우.
- 충돌을 허용하고 추후에 병합하는 방법이 있음.

### 쓰기 스큐를 특징짓기
- 갱신 손실과 다른 점: 두 트랜잭션이 다른 두 객체를 갱신함으로써 발생하는 일관성 문제.
  - COUNT같은 집계에서 발생할 수 있음.

### 쓰기 스큐를 유발하는 팬텀
1. 검색 조건에 해당하는 로우를 SELECT로 조회함.
2. 조회 결과로 어떻게 쓰기 작업을 진행할 지 결정.
3. 다른 트랜잭션이 커밋되기 전에 조회하고 조건 처리.
4. 문제 발생.
- Phantom: 어떤 트랜잭션에서 실행한 쓰기가 다른 트랜잭션의 검색 질의 결과를 바꾸는 효과.

***
## 직렬성

### 실제적인 직렬 실행
- 단일 스레드로 순차적 처리
  - 메모리가 발달하면서 메모리에 데이터셋을 올려놓고 디스크 I/O를 줄였기 때문에 단일 스레드로도 효과적.
  - ex) Redis: 멀티플렉싱으로 들어오는 요청 효과적으로 받고, 이벤트 루프로 순차적 처리.

### 트랜잭션을 스토어드 프로시저 안에 캡슐화하기
- 대부분은 애플리케이션과 데이터베이스가 상호작용하면서 트랜잭션을 처리한다. => 네트워크에 리소스 많이 소모.
- 스토어드 프로시져: 트랜잭션 코드 전체를 디비에 제출.

### 스토어드 프로시저의 장단점
- 디비가 처리 로직을 가지고 있어 단일 스레드로 효과적인 트랜잭션 처리 가능.
- 디비에서 코드의 관리 어려움 => 점점 발전하고 있다고 함.

### 파티셔닝
- 디비를 나누어서 각 디비에서 단일 스레드로 처리.
- 해당 트랜잭션에 사용되는 모든 파티션을 코디네이션 해야함. => 이게 어려움.

***
## 2단계 잠금 2PL
- 2-phase locking
- 객체가 트랜잭션에 의해 점유중 일때, 다른 트랜잭션이 이를 읽거나 쓰려면 커밋되거나 어보트될 때까지 기다려야 함.

### 2단계 잠금 구현
- 읽기 시 공유/독점 모드로 락 획득.
- 쓰기 시 독점 모드로 락 획득.

### 서술 잠금
- 직렬성 격리에서 팬텀을 없애기 위한 잠금.
- 서술 잠금: 검색 조건에 부합하는 모든 객체를 잠금.

### 색인 범위 잠금
- 조회 조건에 해당하는 색인 키 범위 전체에 대해 잠금.

***
## 직렬성 스냅숏 격리
- 완전한 직렬성 + 스냅숏보다 약간 못미치는 성능
- 낙관적 + 읽기 시 스냅숏 방식
  - 트랜잭션을 모니터링하면서 문제생기면 어보트
- 잠금이 없다는 점에서 성능적 이점.

***
## 정리

### 트랜잭션?
- 여러 명령어를 하나의 논리적인 단위로 묶는 일종의 개념.
  - 어보트를 통해 재시도.
  - 커밋을 통한 확정

### 격리 수준에 따른 문제들
- 더티 읽기: 커밋되지 않은 데이터 조회 가능.
- 더티 쓰기: 커밋되지 않은 데이터 덮어쓰기 가능.
- 갱신 손실: 다른 트랜잭션 변경을 생각 안하고 덮어써서 데이터 손실.
- 읽기 스큐: 다른 시점에 DB의 다른 부분을 조회.
- 쓰기 스큐: 데이터를 보고 조건에 따라 결정했는데, 옜날 데이터인 경우.
- 팬텀 읽기: 검색 결과에 영향을 미치는 객체에 변경이 가해지는 경우.

### 직렬성
- 순차적 실행, 2PL, SSI로 해결할수는 있지만, 성능 vs 일관성.