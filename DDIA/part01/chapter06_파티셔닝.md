# 06장 파티셔닝

대용량 데이터, 질의가 복제만으로 부족하다면? => 샤딩
- 샤딩: 데이터를 파티션으로 쪼개는 것. (파티셔닝)
- 복제와 다른 점은 가지고 있는 **데이터들이 다르다**는 점이다.

---
## 키-값 데이터 파티셔닝
- skewed: 다른 파티션보다 질의를 많이 받는 경우
- 핫스팟: 부하가 높은 파티션
  - 핫스팟을 해결하기 위해 데이터를 무작위로 배분할 수 있다. => **데이터의 위치를 모르게 된다.**

### 키 범위 기준 파티셔닝
- 연속된 범위의 키를 할당
  - 키 범위가 꼭 동일할 필요는 없음 => **불균등 해소**
- range scan에 유리
- 한계점: 특정한 접근 패턴이 핫스팟 유발 (ex: 센서 데이터베이스)

### 키의 해시값 기준 파티셔닝
- 키를 해싱해서 파티션 결정.
  - 파티션은 해시값 범위를 가짐.
  - 프로그래밍 언어의 해시 함수는 안전하지 않은 것에 유의.
- 한계점: range scan이 불가능하다.
  - Mongo에서는 모든 파티션에 질의를 보내 Range scan이 이루어진다고 한다.

### 쏠림 작업부하와 핫스팟 완화
- 동일한 키에 대해 작업이 몰림.
- 애플리케이션에서 해결.
  - 몰리는 키 자체를 분할 => 요청이 몰리는 키에만 적용. 왜냐? 쓰기 작업이 늘어남. + 분할된 키 추적 필요.
    - id = 1 인 키면 1-1, 1-2 이런 식.

|  id   | 이름  |
|:-----:|:---:|
| 1 - 1 | 유재석 |
| 1 - 2 | 유재석 |
| 1 - 3 | 유재석 |
|   2   | 박종하 |
|   3   | 문진수 |



---

## 파티셔닝과 보조 색인
- 보조 색인: 특정한 값이 발생한 항목을 검색하는 수단.

### 문서 기준 보조 색인 파티셔닝
- 각 파티션마다 보조 색인(역인덱스)를 만들고, 모든 파티션에 질의를 돌림.
- 질의 시에는 모든 파티션에 = scatter/gather
  - 파티션 별로 보조 색인에 해당하는 데이터만을 넣으면 해결되는데, 쉬운 일이 아니다.
- 쓰기 시에는 문서 ID에 해당하는 파티션에 

### 용어 기준 보조 색인 파티셔닝
- 색인별로 파티션을 만드는 것.
- 질의 시에는 해당 색인을 가지는 파티션에.
- 쓰기 작업은 이제 해당 데이터가 속할 수 있는 색인 파티션 전부에 => 근데 이제 분산 트랜잭션이 필요한.

*결국 쓰기 vs 읽기

---

## 파티션 재균형화
- 파티션간 데이터를 옮겨야 하는 경우가 생김. => Rebalancing
  - 최소로 옮기기, 균등하게, 와중에도 요청받을 수 있게

### 쓰면 안되는 방법: 해시값에 모드 N 연산을 실행
- 노드 수가 바뀌는데 모듈려 연산 때리면 너무 많이 바뀐다.

### 파티션 개수 고정
- 한 노드에 여러 파티션을 배정.
- 노드 추가 시 기존 노드에서 파티션 가져오기.
- 적절한 파티션 개수 선정 필요.

### 동적 파티셔닝
- B트리처럼 파티션을 동적으로 분할.
- 사전에 세팅해놓고(사전 분할), 후에 이제 동적으로.

### 노드 비례 파티셔닝
- 노드가 추가하면 노드 수에 비례해서 기존 파티션 분할 후 할당.
- 파티션 경계를 무작위로 설정해야 하기 때문에 => 해시 유용.

---

## 요청 라우팅
- 트래픽을 적절한 파티션으로. => **서비스 찾기**
    - 아무 노드로 보내고 찾을 때까지 = DFS
    - 라우팅 계층을 거쳐 찾기.
    - 클라이언트측에 정보 들고 있게 하기.
- 중요한 점은 **노드에 할당된 파티션의 변경을 알아내는 것.**
  - Zookeeper같은 코디네이션 서비스를 통해 관리. = 매핑 테이블 관리 역할.
  - 노드 사이에 변경 정보 전파해서 리디렉션.
